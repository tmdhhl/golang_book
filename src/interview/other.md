### 0. go运行时，有没有独到的见解？

### 1. go GC的触发方式有哪些？gc算法
- 阈值触发（对象分配触发）-> gcTriggerHeap
	- 需要初始化一个大小超过32KB的大对象
	- 待初始化对象在mcache中对应spanClass的mspan空间已用尽
- 主动触发（用户手动调用GC
- 两分钟定时触发 -> gcTriggerTime
- gcTriggerCycle:runtime 认为需要开始一个新的 GC 周期时触发

**GC Root**：一般包括全局变量和栈对象
**Golang为什么不选择分代垃圾回收机制**：Golang中存在内存逃逸机制，会在编译过程中将生命周期更长的对象转移到堆中，将生命周期短的对象分配在栈上，并以栈为单位对这部分对象进行回收.内存逃逸机制减弱了分代算法对Golang GC所带来的优势，考虑分代算法需要产生额外的成本（如不同年代的规则映射、状态管理以及额外的写屏障），Golang 选择不采用分代GC算法.

**gc和用户goroutine并发的问题：**
- 漏标：a, b, c。a为黑色，b为灰色，c为白色，初始时：b->c。改成a->c, 断开b和c。由于a已经标记为黑色不会再遍历，b也不指向c了，所以c遍历不到，但因为是白色，所以会被清除。不能接受的场景。
- 多标：a->b，a是黑，b时灰色。此时断开a和b，b能删除，但是已经被标灰，所以不会被删除。（容忍态度，放到下一轮GC中进行延后处理）

**解决漏标：**
    - **强三色不变性**：白色对象不能被黑色对象直接引用。插入写屏障（Dijkstra）的目标是实现强三色不变式，保证当一个黑色对象指向一个白色对象前，会先触发屏障将白色对象置为灰色，再建立引用.
	- **弱三色不变形**：白色对象可以被黑色对象引用，但要从某个灰对象出发仍然可达该白对象。删除写屏障（Yuasa barrier）的目标是实现弱三色不变式，保证当一个白色对象即将被上游删除引用前，会触发屏障将其置灰，之后再删除上游指向其的引用.

屏障机制无法作用于栈对象。因为栈对象可能涉及频繁的轻量操作，倘若这些高频度操作都需要一一触发屏障机制，那么所带来的成本将是无法接受的。

在这个背景下，单独看插入写屏障或删除写屏障，都无法真正解决漏标问题，除非我们引入额外的Stop the world（STW）阶段，对栈对象的处理进行兜底。（即栈的重扫描过程）

为了消除这个额外的 STW 成本，Golang 1.8 引入了混合写屏障机制，可以视为糅合了插入写屏障+删除写屏障的加强版本，要点如下：
- GC 开始前，以栈为单位分批扫描，将栈中所有对象置黑
- GC 期间，栈上新创建对象直接置黑
- 堆对象正常启用插入写屏障
- 堆对象正常启用删除写屏障

为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要将创建的所有新对象都标记成黑色，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。


Go 语言的垃圾收集可以分成清除终止、标记、标记终止和清除四个不同阶段：
1. 清理终止阶段；
	1. 暂停程序，所有的处理器在这时会进入安全点（Safe point）；
	2. 如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；
2. 标记阶段；
	1. 将状态切换至 _GCmark、开启写屏障、用户程序协助（Mutator Assists）并将根对象入队；
	2. 恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；
	3. 开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；
	4. 依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
	5. 使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；
3. 标记终止阶段；
	1. 暂停程序、将状态切换至 _GCmarktermination 并关闭辅助标记的用户程序；
	2. 清理处理器上的线程缓存；
4. 清理阶段；
	1. 将状态切换至 _GCoff 开始清理阶段，初始化清理状态并关闭写屏障；
	2. 恢复用户程序，所有新创建的对象会标记成白色；
	3. 后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；

### 2. GMP模型？P和M的最大值？goroutine是在P还是全局队列创建的？文件IO时G怎么调度的？
**GMP模型**：G-goroutine，m-物理线程的封装，p-存储g，绑定到M后g可以被执行，是G眼里的cpu。

**P和M的最大值**：M最大10000，P：GOMAXPROCS限制。二者默认都是GOMAXPROCS

**调度流程**：首先是schedule()函数，调用findRunable()去寻找g，找到g后，调用gogo()切换到g上进行运行。
运行过程中，如果遇到系统调用，是异步系统调用（网络IO），就把g挂载到netpoll上，m继续执行p中其他的g。如果是同步系统调用（如文件IO），会阻塞g和m，此时将p与m分离，但是m会记录oldP，p重新寻找m以运行里面的g，如果没有可用的m，就新建。

当异步系统调用完成时，g会被放到某个P的Runnext中执行。同步系统调用返回时，会优先尝试获取m对应的oldP，不行（因为Go 的 sysmon（内部监控线程）发现有这种卡了超过 10 ms 的 M ，那么就会把 P 剥离出来，给到其他的 M 去处理执行，M 数量不够就会新创建。）就去找其他P，如果没有可用，就把g设置为可执行状态放到全局队列中，m则挂起，加入到空闲线程中。

**主动调度**：
	- 主动调度
	- 同步内存访问，加锁等阻塞操作
	- 正常执行结束角度

**抢占式调度**：
	- 由sysmon（不需要p就能执行）负责，如果检测到某个P的状态为Prunning，并且它已经运行了超过10ms，则会将P的当前的G的stackguard设置为StackPreempt。这个操作其实是相当于加上一个标记，通知这个G在合适时机进行调度。Go会在每个函数入口处比较当前的栈寄存器值和stackguard值来决定是否触发morestack函数。将stackguard设置为StackPreempt作用是进入函数时必定触发morestack，然后在morestack中再引发调度。（但是如果是死循环，不会再次进入函数，就抢占不了了）
	- 基于信号的抢占（也叫异步抢占）：preemptM()通过runtime.signalM()向制定的m发送sigPreempt信号，m接收到信号执行runtime.sighandler()调用doSigPreempt()确认执行上下文能安全抢占后进行异步抢占。
	
	异步抢占的本质是在为垃圾回收器服务。

	> 1. M1 发送中断信号（signalM(mp, sigPreempt)）
	> 2. M2 收到信号，操作系统中断其执行代码，并切换到信号处理函数（sighandler(signum, info, ctxt, gp)）
	> 3. M2 修改执行的上下文，并恢复到修改后的位置（asyncPreempt）
	> 4. 重新进入调度循环进而调度其他 Goroutine（preemptPark 和 gopreempt_m)

**sysmon的作用**：
- 释放闲置超过5分钟的span物理内存
- 如果超过2分钟没有执行垃圾回收，强制执行
- 将长时间未处理的netpoll结果添加到任务队列
- 向长时间(10ms)运行的G发出抢占调度
- 收回因同步syscall长时间阻塞的P

**GO调度的时机**
1. 使用关键字go
2. GC，因为GC的goroutine要在m上运行，所以要进行调度
3. 系统调用
4. 同步内存访问
5. 手动调用runtime.Gosched()


** m的自旋
为了避免频繁地挂起和恢复M。分为两种自旋，二者之和不超过GOMAXPROCS
1. 有关联P的M，自旋寻找可执行的G
2. 无关联P的M，自旋寻找可用的P

当第二种自旋M存在时，第一种自旋的M不会被挂起。


> ![golang 系统调用与阻塞处理](https://qiankunli.github.io/2020/11/21/goroutine_system_call.html)
> ![抢占式调度](https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.5.html)
> ![Golang GMP 原理](https://mp.weixin.qq.com/s/jIWe3nMP6yiuXeBQgmePDg)
> ![goroutine调度器揭秘 2](https://colobu.com/2024/03/24/goroutine-scheduler-2/)
> ![详解Go语言调度循环源码实现](https://www.luozhiyun.com/archives/448)
> ![GMP 原理与调度](https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html)
> ![Go 语言设计与实现](https://draven.co/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/)


3. channel底层原理？使用场景，什么时候会panic、阻塞？
4. context原理、使用场景
5. select场景
6. interface{}使用场景、大小比较
7. 容量为1的channel在什么情况下会阻塞
8. sync.Once是如何实现的，如何不使用sync.Once实现单例模式？
9. Map的底层原理，是否并发安全
10. Slice的底层原理，是否并发安全，和数组的区别
11. sync.Map的底层原理
12. sync.Mutex的底层原理
13. 内存分配？泄漏的排查思路
**划分不同大小的好处**：能够消解外部碎片的问题，将问题限制在相对可控的内部碎片当中



14. go struct能不能比较
15. 逃逸分析是什么？怎么避免内存逃逸
16. automic里的cas方法，里面实现又没有加锁。原子操作和go的锁有什么区别？
17. 抢占式调度
	抢占式调度：由sysmon（不需要p就能执行）负责，如果检测到某个P的状态为Prunning，并且它已经运行了超过10ms，则会将P的当前的G的stackguard设置为StackPreempt。这个操作其实是相当于加上一个标记，通知这个G在合适时机进行调度。

	Go会在每个函数入口处比较当前的栈寄存器值和stackguard值来决定是否触发morestack函数。将stackguard设置为StackPreempt作用是进入函数时必定触发morestack，然后在morestack中再引发调度。

> ![抢占式调度](https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.5.html)

18. defer语句的执行顺序
19. for range的使用中，地址会发生变化吗


场景题：
1. 从无限的字符流中，随机选出10个字符
2. 设计一个抢红包的系统架构，如何保证每个人抢到、如何扛住流量？
3. 给你一个10PB文件 3000台机器，怎么做字典树排序？
4. 一个文件里有40亿个数字，找出最大的10个数字